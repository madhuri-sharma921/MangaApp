package com.example.mangaverseapp.repository

import com.example.mangaverseapp.data.local.dao.UserDao
import com.example.mangaverseapp.data.local.entity.UserEntity
import com.example.mangaverseapp.domain.model.User
import com.example.mangaverseapp.domain.repository.UserRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class UserRepositoryImpl @Inject constructor(
    private val userDao: UserDao
) : UserRepository {

    override suspend fun signIn(email: String, password: String): Result<User> {
        val existingUser = userDao.getUserByEmail(email)

        return if (existingUser != null) {
            if (existingUser.password == password) {
                // User exists and password matches
                userDao.setUserLoggedIn(existingUser.id)
                Result.success(existingUser.toDomain())
            } else {
                // Password doesn't match
                Result.failure(Exception("Invalid password"))
            }
        } else {
            // User doesn't exist
            Result.failure(Exception("User not found"))
        }
    }

    override suspend fun createUser(email: String, password: String): Result<User> {
        // Check if user with email already exists
        val existingUser = userDao.getUserByEmail(email)

        if (existingUser != null) {
            return Result.failure(Exception("Email already in use"))
        }

        // Create new user entity with auto-generated ID
        val newUser = UserEntity(
            id = 0, // This will be auto-generated by Room
            email = email,
            password = password,
            isLoggedIn = true // Set user as logged in immediately
        )

        // Insert into database and get the inserted ID
        val insertedId = userDao.insertUser(newUser).toInt()

        // Return success with user domain object using the inserted ID
        return Result.success(User(
            id = insertedId,
            email = email,
            password = password
        ))
    }

    override fun getCurrentUser(): Flow<User?> {
        return userDao.getLoggedInUser().map { it?.toDomain() }
    }

    override suspend fun signOut() {
        userDao.logoutAllUsers()
    }

    private fun UserEntity.toDomain(): User {
        return User(
            id = id,
            email = email,
            password = password
        )
    }
}